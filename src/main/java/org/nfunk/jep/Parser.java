/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package org.nfunk.jep;

@SuppressWarnings({ "serial", "rawtypes", "unchecked", "unused" })
public class Parser/* @bgen(jjtree) */ implements ParserTreeConstants, ParserConstants
{/* @bgen(jjtree) */
    static final class JJCalls
    {
        int     gen;
        Token   first;
        int     arg;
        JJCalls next;
    }

    static private final class LookaheadSuccess extends java.lang.Error
    {
    }

    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static
    {
        Parser.jj_la1_0();
        Parser.jj_la1_1();
    }

    private static void jj_la1_0()
    {
        Parser.jj_la1_0 = new int[] { 0x80001, 0x80001, 0x80001, 0x10000000, 0x8000000, 0x4800000, 0x4800000, 0x3600000,
                0x3600000, 0x60000000, 0x60000000, 0x80000000, 0x60000000, 0x0, 0x9000, 0xa80, 0x0, 0x100000, 0x100000,
                0x9000, 0xa80, 0x280, };
    }

    private static void jj_la1_1()
    {
        Parser.jj_la1_1 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x27, 0x8, 0x10, 0x0, 0x0,
                0x140, 0x0, 0x0, 0x0, 0x0, 0x0, };
    }

    protected JJTParserState jjtree = new JJTParserState();

    private JEP jep;

    private SymbolTable symTab;
    private OperatorSet opSet;

    private int initialTokenManagerState = ParserConstants.DEFAULT;

    public ParserTokenManager token_source;

    JavaCharStream jj_input_stream;

    public Token token, jj_nt;

    private int jj_ntk;

    private Token jj_scanpos, jj_lastpos;

    private int jj_la;

    public boolean lookingAhead = false;

    private boolean jj_semLA;

    private int jj_gen;

    final private int[] jj_la1 = new int[22];

    final private JJCalls[] jj_2_rtns = new JJCalls[8];

    private boolean jj_rescan = false;

    private int jj_gc = 0;

    final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    private final java.util.Vector jj_expentries = new java.util.Vector();

    private int[] jj_expentry;

    private int jj_kind = -1;

    private final int[] jj_lasttokens = new int[100];

    private int jj_endpos;

    public Parser(java.io.InputStream stream)
    {
        this.jj_input_stream = new JavaCharStream(stream, 1, 1);
        this.token_source = new ParserTokenManager(this.jj_input_stream);
        this.token = new Token();
        this.jj_ntk = -1;
        this.jj_gen = 0;
        for (int i = 0; i < 22; i++)
            this.jj_la1[i] = -1;
        for (int i = 0; i < this.jj_2_rtns.length; i++)
            this.jj_2_rtns[i] = new JJCalls();
    }

    public Parser(java.io.Reader stream)
    {
        this.jj_input_stream = new JavaCharStream(stream, 1, 1);
        this.token_source = new ParserTokenManager(this.jj_input_stream);
        this.token = new Token();
        this.jj_ntk = -1;
        this.jj_gen = 0;
        for (int i = 0; i < 22; i++)
            this.jj_la1[i] = -1;
        for (int i = 0; i < this.jj_2_rtns.length; i++)
            this.jj_2_rtns[i] = new JJCalls();
    }

    public Parser(ParserTokenManager tm)
    {
        this.token_source = tm;
        this.token = new Token();
        this.jj_ntk = -1;
        this.jj_gen = 0;
        for (int i = 0; i < 22; i++)
            this.jj_la1[i] = -1;
        for (int i = 0; i < this.jj_2_rtns.length; i++)
            this.jj_2_rtns[i] = new JJCalls();
    }

    final public void AdditiveExpression() throws ParseException
    {
        this.MultiplicativeExpression();
        label_5:
        while (true)
        {
            switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case PLUS:
            case MINUS:
                ;
                break;
            default:
                this.jj_la1[9] = this.jj_gen;
                break label_5;
            }
            switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case PLUS:
                final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc001 = true;
                this.jjtree.openNodeScope(jjtn001);
                try
                {
                    this.jj_consume_token(ParserConstants.PLUS);
                    this.MultiplicativeExpression();
                    this.jjtree.closeNodeScope(jjtn001, 2);
                    jjtc001 = false;
                    jjtn001.setOperator(this.opSet.getAdd());
                }
                catch (final Throwable jjte001)
                {
                    if (jjtc001)
                    {
                        this.jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte001 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte001;
                    }
                    if (jjte001 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte001;
                    }
                    {
                        if (true) throw (Error) jjte001;
                    }
                }
                finally
                {
                    if (jjtc001) this.jjtree.closeNodeScope(jjtn001, 2);
                }
                break;
            case MINUS:
                final ASTFunNode jjtn002 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc002 = true;
                this.jjtree.openNodeScope(jjtn002);
                try
                {
                    this.jj_consume_token(ParserConstants.MINUS);
                    this.MultiplicativeExpression();
                    this.jjtree.closeNodeScope(jjtn002, 2);
                    jjtc002 = false;
                    jjtn002.setOperator(this.opSet.getSubtract());
                }
                catch (final Throwable jjte002)
                {
                    if (jjtc002)
                    {
                        this.jjtree.clearNodeScope(jjtn002);
                        jjtc002 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte002 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte002;
                    }
                    if (jjte002 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte002;
                    }
                    {
                        if (true) throw (Error) jjte002;
                    }
                }
                finally
                {
                    if (jjtc002) this.jjtree.closeNodeScope(jjtn002, 2);
                }
                break;
            default:
                this.jj_la1[10] = this.jj_gen;
                this.jj_consume_token(-1);
                throw new ParseException();
            }
        }
    }

    private void addToErrorList(String errorStr)
    {
        this.jep.errorList.addElement(errorStr);
    }

    final public void AndExpression() throws ParseException
    {
        this.EqualExpression();
        label_2:
        while (true)
        {
            switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case AND:
                ;
                break;
            default:
                this.jj_la1[4] = this.jj_gen;
                break label_2;
            }
            final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
            boolean jjtc001 = true;
            this.jjtree.openNodeScope(jjtn001);
            try
            {
                this.jj_consume_token(ParserConstants.AND);
                this.EqualExpression();
                this.jjtree.closeNodeScope(jjtn001, 2);
                jjtc001 = false;
                jjtn001.setOperator(this.opSet.getAnd());
            }
            catch (final Throwable jjte001)
            {
                if (jjtc001)
                {
                    this.jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                }
                else this.jjtree.popNode();
                if (jjte001 instanceof RuntimeException)
                {
                    if (true) throw (RuntimeException) jjte001;
                }
                if (jjte001 instanceof ParseException)
                {
                    if (true) throw (ParseException) jjte001;
                }
                {
                    if (true) throw (Error) jjte001;
                }
            }
            finally
            {
                if (jjtc001) this.jjtree.closeNodeScope(jjtn001, 2);
            }
        }
    }

    final public void AnyConstant() throws ParseException
    {
        /* @bgen(jjtree) Constant */
        final ASTConstant jjtn000 = new ASTConstant(ParserTreeConstants.JJTCONSTANT);
        boolean jjtc000 = true;
        this.jjtree.openNodeScope(jjtn000);
        Token t;
        Object value;
        try
        {
            switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case STRING_LITERAL:
                t = this.jj_consume_token(ParserConstants.STRING_LITERAL);
                this.jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                // strip away double quotes at end of string
                String temp = t.image.substring(1, t.image.length() - 1);

                // replace escape characters
                temp = this.replaceEscape(temp);

                jjtn000.setValue(temp);
                break;
            case INTEGER_LITERAL:
            case FLOATING_POINT_LITERAL:
                value = this.RealConstant();
                this.jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtn000.setValue(value);
                // }
                // |
                // value = Array() {
                // jjtThis.setValue(value);

                break;
            default:
                this.jj_la1[20] = this.jj_gen;
                this.jj_consume_token(-1);
                throw new ParseException();
            }
        }
        catch (final Throwable jjte000)
        {
            if (jjtc000)
            {
                this.jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            }
            else this.jjtree.popNode();
            if (jjte000 instanceof RuntimeException)
            {
                if (true) throw (RuntimeException) jjte000;
            }
            if (jjte000 instanceof ParseException)
            {
                if (true) throw (ParseException) jjte000;
            }
            {
                if (true) throw (Error) jjte000;
            }
        }
        finally
        {
            if (jjtc000) this.jjtree.closeNodeScope(jjtn000, true);
        }
    }

    final public void ArgumentList(int reqArguments, String functionName) throws ParseException
    {
        int count = 0;
        String errorStr = "";
        if (this.jj_2_8(1))
        {
            this.Expression();
            count++;
            label_8:
            while (true)
            {
                switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
                {
                case COMMA:
                    ;
                    break;
                default:
                    this.jj_la1[18] = this.jj_gen;
                    break label_8;
                }
                this.jj_consume_token(ParserConstants.COMMA);
                this.Expression();
                count++;
            }
        }
        else;
        if (reqArguments != count && reqArguments != -1)
        {
            errorStr = "Function \"" + functionName + "\" requires " + reqArguments + " parameter";
            if (reqArguments != 1) errorStr += "s";
            this.addToErrorList(errorStr);
        }
    }

    final public void AssignExpression() throws ParseException
    {
        final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
        boolean jjtc001 = true;
        this.jjtree.openNodeScope(jjtn001);
        try
        {
            this.Variable();
            this.jj_consume_token(ParserConstants.ASSIGN);
            this.Expression();
            this.jjtree.closeNodeScope(jjtn001, 2);
            jjtc001 = false;
            if (!this.jep.getAllowAssignment()) if (true) throw new ParseException(
                    "Syntax Error (assignment not enabled)");

            jjtn001.setOperator(this.opSet.getAssign());
        }
        catch (final Throwable jjte001)
        {
            if (jjtc001)
            {
                this.jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
            }
            else this.jjtree.popNode();
            if (jjte001 instanceof RuntimeException)
            {
                if (true) throw (RuntimeException) jjte001;
            }
            if (jjte001 instanceof ParseException)
            {
                if (true) throw (ParseException) jjte001;
            }
            {
                if (true) throw (Error) jjte001;
            }
        }
        finally
        {
            if (jjtc001) this.jjtree.closeNodeScope(jjtn001, 2);
        }
    }

    /**
     * Continue parsing without re-initilising stream.
     * Allows renetrancy of parser so that strings like
     * "x=1; y=2; z=3;" can be parsed.
     * When a semi colon is encountered parsing finishes leaving the rest of the
     * string unparsed.
     * Parsing can be resumed from the current position by using this method.
     * For example
     * 
     * <pre>
     * XJep j = new XJep();
     * Parser parse = j.getParse();
     * StringReader sr = new StringReader("x=1; y=2; z=3;");
     * parse.restart(sr, j);
     * Node node;
     * try
     * {
     *     while ((node = j.continueParse()) != null)
     *     {
     *         j.println(node);
     *     }
     * }
     * catch (ParseException e)
     * {
     * }
     * </pre>
     */
    public Node continueParse() throws ParseException
    {
        final ASTStart node = this.Start();
        if (node == null) return null;
        return node.jjtGetChild(0);
    }

    final public void disable_tracing()
    {
    }

    final public void enable_tracing()
    {
    }

    final public void EqualExpression() throws ParseException
    {
        this.RelationalExpression();
        label_3:
        while (true)
        {
            switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case EQ:
            case NE:
                ;
                break;
            default:
                this.jj_la1[5] = this.jj_gen;
                break label_3;
            }
            switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case NE:
                final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc001 = true;
                this.jjtree.openNodeScope(jjtn001);
                try
                {
                    this.jj_consume_token(ParserConstants.NE);
                    this.RelationalExpression();
                    this.jjtree.closeNodeScope(jjtn001, 2);
                    jjtc001 = false;
                    jjtn001.setOperator(this.opSet.getNE());
                }
                catch (final Throwable jjte001)
                {
                    if (jjtc001)
                    {
                        this.jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte001 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte001;
                    }
                    if (jjte001 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte001;
                    }
                    {
                        if (true) throw (Error) jjte001;
                    }
                }
                finally
                {
                    if (jjtc001) this.jjtree.closeNodeScope(jjtn001, 2);
                }
                break;
            case EQ:
                final ASTFunNode jjtn002 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc002 = true;
                this.jjtree.openNodeScope(jjtn002);
                try
                {
                    this.jj_consume_token(ParserConstants.EQ);
                    this.RelationalExpression();
                    this.jjtree.closeNodeScope(jjtn002, 2);
                    jjtc002 = false;
                    jjtn002.setOperator(this.opSet.getEQ());
                }
                catch (final Throwable jjte002)
                {
                    if (jjtc002)
                    {
                        this.jjtree.clearNodeScope(jjtn002);
                        jjtc002 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte002 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte002;
                    }
                    if (jjte002 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte002;
                    }
                    {
                        if (true) throw (Error) jjte002;
                    }
                }
                finally
                {
                    if (jjtc002) this.jjtree.closeNodeScope(jjtn002, 2);
                }
                break;
            default:
                this.jj_la1[6] = this.jj_gen;
                this.jj_consume_token(-1);
                throw new ParseException();
            }
        }
    }

    // Expresions can be like
    // x=3
    // x=y=3 parsed as x=(y=3)
    final public void Expression() throws ParseException
    {
        if (this.jj_2_2(3)) this.AssignExpression();
        else if (this.jj_2_3(1)) this.OrExpression();
        else
        {
            this.jj_consume_token(-1);
            throw new ParseException();
        }
    }

    final public void Function() throws ParseException
    {
        int reqArguments = 0;
        String identString = "";
        final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
        boolean jjtc001 = true;
        this.jjtree.openNodeScope(jjtn001);
        try
        {
            identString = this.Identifier();
            if (this.jep.funTab.containsKey(identString))
            {
                // Set number of required arguments
                reqArguments = this.jep.funTab.get(identString).getNumberOfParameters();
                jjtn001.setFunction(identString, this.jep.funTab.get(identString));
            }
            else this.addToErrorList("!!! Unrecognized function \"" + identString + "\"");
            this.jj_consume_token(ParserConstants.LRND);
            this.ArgumentList(reqArguments, identString);
            this.jj_consume_token(ParserConstants.RRND);
        }
        catch (final Throwable jjte001)
        {
            if (jjtc001)
            {
                this.jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
            }
            else this.jjtree.popNode();
            if (jjte001 instanceof RuntimeException)
            {
                if (true) throw (RuntimeException) jjte001;
            }
            if (jjte001 instanceof ParseException)
            {
                if (true) throw (ParseException) jjte001;
            }
            {
                if (true) throw (Error) jjte001;
            }
        }
        finally
        {
            if (jjtc001) this.jjtree.closeNodeScope(jjtn001, true);
        }
    }

    public ParseException generateParseException()
    {
        this.jj_expentries.removeAllElements();
        final boolean[] la1tokens = new boolean[42];
        for (int i = 0; i < 42; i++)
            la1tokens[i] = false;
        if (this.jj_kind >= 0)
        {
            la1tokens[this.jj_kind] = true;
            this.jj_kind = -1;
        }
        for (int i = 0; i < 22; i++)
            if (this.jj_la1[i] == this.jj_gen) for (int j = 0; j < 32; j++)
            {
                if ((Parser.jj_la1_0[i] & 1 << j) != 0) la1tokens[j] = true;
                if ((Parser.jj_la1_1[i] & 1 << j) != 0) la1tokens[32 + j] = true;
            }
        for (int i = 0; i < 42; i++)
            if (la1tokens[i])
            {
                this.jj_expentry = new int[1];
                this.jj_expentry[0] = i;
                this.jj_expentries.addElement(this.jj_expentry);
            }
        this.jj_endpos = 0;
        this.jj_rescan_token();
        this.jj_add_error_token(0, 0);
        final int[][] exptokseq = new int[this.jj_expentries.size()][];
        for (int i = 0; i < this.jj_expentries.size(); i++)
            exptokseq[i] = (int[]) this.jj_expentries.elementAt(i);
        return new ParseException(this.token, exptokseq, ParserConstants.tokenImage);
    }

    final public Token getNextToken()
    {
        if (this.token.next != null) this.token = this.token.next;
        else this.token = this.token.next = this.token_source.getNextToken();
        this.jj_ntk = -1;
        this.jj_gen++;
        return this.token;
    }

    final public Token getToken(int index)
    {
        Token t = this.lookingAhead ? this.jj_scanpos : this.token;
        for (int i = 0; i < index; i++)
            if (t.next != null) t = t.next;
            else t = t.next = this.token_source.getNextToken();
        return t;
    }

    final public String Identifier() throws ParseException
    {
        Token t;
        switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
        {
        case INDENTIFIER1:
            t = this.jj_consume_token(ParserConstants.INDENTIFIER1);
            break;
        case INDENTIFIER2:
            t = this.jj_consume_token(ParserConstants.INDENTIFIER2);
            break;
        default:
            this.jj_la1[19] = this.jj_gen;
            this.jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if (true) return t.image;
        }
        throw new Error("Missing return statement in function");
    }

    final private boolean jj_2_1(int xla)
    {
        this.jj_la = xla;
        this.jj_lastpos = this.jj_scanpos = this.token;
        try
        {
            return !this.jj_3_1();
        }
        catch (final LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            this.jj_save(0, xla);
        }
    }

    final private boolean jj_2_2(int xla)
    {
        this.jj_la = xla;
        this.jj_lastpos = this.jj_scanpos = this.token;
        try
        {
            return !this.jj_3_2();
        }
        catch (final LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            this.jj_save(1, xla);
        }
    }

    final private boolean jj_2_3(int xla)
    {
        this.jj_la = xla;
        this.jj_lastpos = this.jj_scanpos = this.token;
        try
        {
            return !this.jj_3_3();
        }
        catch (final LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            this.jj_save(2, xla);
        }
    }

    final private boolean jj_2_4(int xla)
    {
        this.jj_la = xla;
        this.jj_lastpos = this.jj_scanpos = this.token;
        try
        {
            return !this.jj_3_4();
        }
        catch (final LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            this.jj_save(3, xla);
        }
    }

    final private boolean jj_2_5(int xla)
    {
        this.jj_la = xla;
        this.jj_lastpos = this.jj_scanpos = this.token;
        try
        {
            return !this.jj_3_5();
        }
        catch (final LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            this.jj_save(4, xla);
        }
    }

    final private boolean jj_2_6(int xla)
    {
        this.jj_la = xla;
        this.jj_lastpos = this.jj_scanpos = this.token;
        try
        {
            return !this.jj_3_6();
        }
        catch (final LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            this.jj_save(5, xla);
        }
    }

    final private boolean jj_2_7(int xla)
    {
        this.jj_la = xla;
        this.jj_lastpos = this.jj_scanpos = this.token;
        try
        {
            return !this.jj_3_7();
        }
        catch (final LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            this.jj_save(6, xla);
        }
    }

    final private boolean jj_2_8(int xla)
    {
        this.jj_la = xla;
        this.jj_lastpos = this.jj_scanpos = this.token;
        try
        {
            return !this.jj_3_8();
        }
        catch (final LookaheadSuccess ls)
        {
            return true;
        }
        finally
        {
            this.jj_save(7, xla);
        }
    }

    final private boolean jj_3_1()
    {
        if (this.jj_3R_9()) return true;
        return false;
    }

    final private boolean jj_3_2()
    {
        if (this.jj_3R_10()) return true;
        return false;
    }

    final private boolean jj_3_3()
    {
        if (this.jj_3R_11()) return true;
        return false;
    }

    final private boolean jj_3_4()
    {
        Token xsp;
        xsp = this.jj_scanpos;
        if (this.jj_3_5())
        {
            this.jj_scanpos = xsp;
            if (this.jj_3R_12())
            {
                this.jj_scanpos = xsp;
                if (this.jj_3R_13())
                {
                    this.jj_scanpos = xsp;
                    if (this.jj_3R_14())
                    {
                        this.jj_scanpos = xsp;
                        if (this.jj_3R_15())
                        {
                            this.jj_scanpos = xsp;
                            if (this.jj_3R_16()) return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    final private boolean jj_3_5()
    {
        if (this.jj_3R_17()) return true;
        return false;
    }

    final private boolean jj_3_6()
    {
        if (this.jj_3R_17()) return true;
        return false;
    }

    final private boolean jj_3_7()
    {
        Token xsp;
        xsp = this.jj_scanpos;
        this.lookingAhead = true;
        this.jj_semLA = (this.getToken(1).kind == ParserConstants.INDENTIFIER1 || this.getToken(
                1).kind == ParserConstants.INDENTIFIER2) && this.jep.funTab.containsKey(this.getToken(1).image);
        this.lookingAhead = false;
        if (!this.jj_semLA || this.jj_3R_18())
        {
            this.jj_scanpos = xsp;
            if (this.jj_3R_19()) return true;
        }
        return false;
    }

    final private boolean jj_3_8()
    {
        if (this.jj_3R_9()) return true;
        return false;
    }

    final private boolean jj_3R_10()
    {
        if (this.jj_3R_20()) return true;
        if (this.jj_scan_token(ParserConstants.ASSIGN)) return true;
        if (this.jj_3R_9()) return true;
        return false;
    }

    final private boolean jj_3R_11()
    {
        if (this.jj_3R_21()) return true;
        return false;
    }

    final private boolean jj_3R_12()
    {
        if (this.jj_scan_token(ParserConstants.MUL)) return true;
        return false;
    }

    final private boolean jj_3R_13()
    {
        if (this.jj_scan_token(ParserConstants.DOT)) return true;
        return false;
    }

    final private boolean jj_3R_14()
    {
        if (this.jj_scan_token(ParserConstants.CROSS)) return true;
        return false;
    }

    final private boolean jj_3R_15()
    {
        if (this.jj_scan_token(ParserConstants.DIV)) return true;
        return false;
    }

    final private boolean jj_3R_16()
    {
        if (this.jj_scan_token(ParserConstants.MOD)) return true;
        return false;
    }

    final private boolean jj_3R_17()
    {
        if (this.jj_3R_22()) return true;
        return false;
    }

    final private boolean jj_3R_18()
    {
        if (this.jj_3R_23()) return true;
        return false;
    }

    final private boolean jj_3R_19()
    {
        if (this.jj_3R_20()) return true;
        return false;
    }

    final private boolean jj_3R_20()
    {
        if (this.jj_3R_24()) return true;
        return false;
    }

    final private boolean jj_3R_21()
    {
        if (this.jj_3R_25()) return true;
        return false;
    }

    final private boolean jj_3R_22()
    {
        Token xsp;
        xsp = this.jj_scanpos;
        if (this.jj_3R_26())
        {
            this.jj_scanpos = xsp;
            if (this.jj_3_7())
            {
                this.jj_scanpos = xsp;
                if (this.jj_3R_27())
                {
                    this.jj_scanpos = xsp;
                    if (this.jj_3R_28()) return true;
                }
            }
        }
        return false;
    }

    final private boolean jj_3R_23()
    {
        if (this.jj_3R_24()) return true;
        return false;
    }

    final private boolean jj_3R_24()
    {
        Token xsp;
        xsp = this.jj_scanpos;
        if (this.jj_scan_token(12))
        {
            this.jj_scanpos = xsp;
            if (this.jj_scan_token(15)) return true;
        }
        return false;
    }

    final private boolean jj_3R_25()
    {
        if (this.jj_3R_29()) return true;
        return false;
    }

    final private boolean jj_3R_26()
    {
        if (this.jj_3R_30()) return true;
        return false;
    }

    final private boolean jj_3R_27()
    {
        if (this.jj_scan_token(ParserConstants.LRND)) return true;
        return false;
    }

    final private boolean jj_3R_28()
    {
        if (this.jj_3R_31()) return true;
        return false;
    }

    final private boolean jj_3R_29()
    {
        if (this.jj_3R_32()) return true;
        return false;
    }

    final private boolean jj_3R_30()
    {
        Token xsp;
        xsp = this.jj_scanpos;
        if (this.jj_3R_33())
        {
            this.jj_scanpos = xsp;
            if (this.jj_3R_34()) return true;
        }
        return false;
    }

    final private boolean jj_3R_31()
    {
        if (this.jj_scan_token(ParserConstants.LSQ)) return true;
        return false;
    }

    final private boolean jj_3R_32()
    {
        if (this.jj_3R_35()) return true;
        return false;
    }

    final private boolean jj_3R_33()
    {
        if (this.jj_scan_token(ParserConstants.STRING_LITERAL)) return true;
        return false;
    }

    final private boolean jj_3R_34()
    {
        if (this.jj_3R_36()) return true;
        return false;
    }

    final private boolean jj_3R_35()
    {
        if (this.jj_3R_37()) return true;
        return false;
    }

    final private boolean jj_3R_36()
    {
        Token xsp;
        xsp = this.jj_scanpos;
        if (this.jj_scan_token(7))
        {
            this.jj_scanpos = xsp;
            if (this.jj_scan_token(9)) return true;
        }
        return false;
    }

    final private boolean jj_3R_37()
    {
        Token xsp;
        xsp = this.jj_scanpos;
        if (this.jj_3R_38())
        {
            this.jj_scanpos = xsp;
            if (this.jj_3R_39())
            {
                this.jj_scanpos = xsp;
                if (this.jj_3R_40())
                {
                    this.jj_scanpos = xsp;
                    if (this.jj_3_6()) return true;
                }
            }
        }
        return false;
    }

    final private boolean jj_3R_38()
    {
        if (this.jj_scan_token(ParserConstants.PLUS)) return true;
        return false;
    }

    final private boolean jj_3R_39()
    {
        if (this.jj_scan_token(ParserConstants.MINUS)) return true;
        return false;
    }

    final private boolean jj_3R_40()
    {
        if (this.jj_scan_token(ParserConstants.NOT)) return true;
        return false;
    }

    final private boolean jj_3R_9()
    {
        Token xsp;
        xsp = this.jj_scanpos;
        if (this.jj_3_2())
        {
            this.jj_scanpos = xsp;
            if (this.jj_3_3()) return true;
        }
        return false;
    }

    private void jj_add_error_token(int kind, int pos)
    {
        if (pos >= 100) return;
        if (pos == this.jj_endpos + 1) this.jj_lasttokens[this.jj_endpos++] = kind;
        else if (this.jj_endpos != 0)
        {
            this.jj_expentry = new int[this.jj_endpos];
            for (int i = 0; i < this.jj_endpos; i++)
                this.jj_expentry[i] = this.jj_lasttokens[i];
            boolean exists = false;
            for (final java.util.Enumeration e = this.jj_expentries.elements(); e.hasMoreElements();)
            {
                final int[] oldentry = (int[]) e.nextElement();
                if (oldentry.length == this.jj_expentry.length)
                {
                    exists = true;
                    for (int i = 0; i < this.jj_expentry.length; i++)
                        if (oldentry[i] != this.jj_expentry[i])
                        {
                            exists = false;
                            break;
                        }
                    if (exists) break;
                }
            }
            if (!exists) this.jj_expentries.addElement(this.jj_expentry);
            if (pos != 0) this.jj_lasttokens[(this.jj_endpos = pos) - 1] = kind;
        }
    }

    final private Token jj_consume_token(int kind) throws ParseException
    {
        Token oldToken;
        if ((oldToken = this.token).next != null) this.token = this.token.next;
        else this.token = this.token.next = this.token_source.getNextToken();
        this.jj_ntk = -1;
        if (this.token.kind == kind)
        {
            this.jj_gen++;
            if (++this.jj_gc > 100)
            {
                this.jj_gc = 0;
                for (final JJCalls jj_2_rtn : this.jj_2_rtns)
                {
                    JJCalls c = jj_2_rtn;
                    while (c != null)
                    {
                        if (c.gen < this.jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return this.token;
        }
        this.token = oldToken;
        this.jj_kind = kind;
        throw this.generateParseException();
    }

    final private int jj_ntk()
    {
        if ((this.jj_nt = this.token.next) == null) return this.jj_ntk = (this.token.next = this.token_source
                .getNextToken()).kind;
        else return this.jj_ntk = this.jj_nt.kind;
    }

    final private void jj_rescan_token()
    {
        this.jj_rescan = true;
        for (int i = 0; i < 8; i++)
        {
            JJCalls p = this.jj_2_rtns[i];
            do
            {
                if (p.gen > this.jj_gen)
                {
                    this.jj_la = p.arg;
                    this.jj_lastpos = this.jj_scanpos = p.first;
                    switch (i)
                    {
                    case 0:
                        this.jj_3_1();
                        break;
                    case 1:
                        this.jj_3_2();
                        break;
                    case 2:
                        this.jj_3_3();
                        break;
                    case 3:
                        this.jj_3_4();
                        break;
                    case 4:
                        this.jj_3_5();
                        break;
                    case 5:
                        this.jj_3_6();
                        break;
                    case 6:
                        this.jj_3_7();
                        break;
                    case 7:
                        this.jj_3_8();
                        break;
                    }
                }
                p = p.next;
            }
            while (p != null);
        }
        this.jj_rescan = false;
    }

    final private void jj_save(int index, int xla)
    {
        JJCalls p = this.jj_2_rtns[index];
        while (p.gen > this.jj_gen)
        {
            if (p.next == null)
            {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = this.jj_gen + xla - this.jj_la;
        p.first = this.token;
        p.arg = xla;
    }

    final private boolean jj_scan_token(int kind)
    {
        if (this.jj_scanpos == this.jj_lastpos)
        {
            this.jj_la--;
            if (this.jj_scanpos.next == null)
                this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next = this.token_source.getNextToken();
            else this.jj_lastpos = this.jj_scanpos = this.jj_scanpos.next;
        }
        else this.jj_scanpos = this.jj_scanpos.next;
        if (this.jj_rescan)
        {
            int i = 0;
            Token tok = this.token;
            while (tok != null && tok != this.jj_scanpos)
            {
                i++;
                tok = tok.next;
            }
            if (tok != null) this.jj_add_error_token(kind, i);
        }
        if (this.jj_scanpos.kind != kind) return true;
        if (this.jj_la == 0 && this.jj_scanpos == this.jj_lastpos) throw this.jj_ls;
        return false;
    }

    final public void ListExpression() throws ParseException
    {
        /* @bgen(jjtree) FunNode */
        final ASTFunNode jjtn000 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
        boolean jjtc000 = true;
        this.jjtree.openNodeScope(jjtn000);
        jjtn000.setOperator(this.opSet.getList());
        try
        {
            this.jj_consume_token(ParserConstants.LSQ);
            this.Expression();
            label_7:
            while (true)
            {
                switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
                {
                case COMMA:
                    ;
                    break;
                default:
                    this.jj_la1[17] = this.jj_gen;
                    break label_7;
                }
                this.jj_consume_token(ParserConstants.COMMA);
                this.Expression();
            }
            this.jj_consume_token(ParserConstants.RSQ);
        }
        catch (final Throwable jjte000)
        {
            if (jjtc000)
            {
                this.jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            }
            else this.jjtree.popNode();
            if (jjte000 instanceof RuntimeException)
            {
                if (true) throw (RuntimeException) jjte000;
            }
            if (jjte000 instanceof ParseException)
            {
                if (true) throw (ParseException) jjte000;
            }
            {
                if (true) throw (Error) jjte000;
            }
        }
        finally
        {
            if (jjtc000) this.jjtree.closeNodeScope(jjtn000, true);
        }
    }

    final public void MultiplicativeExpression() throws ParseException
    {
        this.UnaryExpression();
        label_6:
        while (true)
        {
            if (this.jj_2_4(1)) ;
            else break label_6;
            if (this.jj_2_5(1))
            {
                final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc001 = true;
                this.jjtree.openNodeScope(jjtn001);
                try
                {
                    this.PowerExpression();
                    this.jjtree.closeNodeScope(jjtn001, 2);
                    jjtc001 = false;
                    if (!this.jep.implicitMul) if (true) throw new ParseException(
                            "Syntax Error (implicit multiplication not enabled)");

                    jjtn001.setOperator(this.opSet.getMultiply());
                }
                catch (final Throwable jjte001)
                {
                    if (jjtc001)
                    {
                        this.jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte001 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte001;
                    }
                    if (jjte001 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte001;
                    }
                    {
                        if (true) throw (Error) jjte001;
                    }
                }
                finally
                {
                    if (jjtc001) this.jjtree.closeNodeScope(jjtn001, 2);
                }
            }
            else switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case MUL:
                final ASTFunNode jjtn002 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc002 = true;
                this.jjtree.openNodeScope(jjtn002);
                try
                {
                    this.jj_consume_token(ParserConstants.MUL);
                    this.UnaryExpression();
                    this.jjtree.closeNodeScope(jjtn002, 2);
                    jjtc002 = false;
                    jjtn002.setOperator(this.opSet.getMultiply());
                }
                catch (final Throwable jjte002)
                {
                    if (jjtc002)
                    {
                        this.jjtree.clearNodeScope(jjtn002);
                        jjtc002 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte002 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte002;
                    }
                    if (jjte002 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte002;
                    }
                    {
                        if (true) throw (Error) jjte002;
                    }
                }
                finally
                {
                    if (jjtc002) this.jjtree.closeNodeScope(jjtn002, 2);
                }
                break;
            case DOT:
                final ASTFunNode jjtn003 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc003 = true;
                this.jjtree.openNodeScope(jjtn003);
                try
                {
                    this.jj_consume_token(ParserConstants.DOT);
                    this.UnaryExpression();
                    this.jjtree.closeNodeScope(jjtn003, 2);
                    jjtc003 = false;
                    jjtn003.setOperator(this.opSet.getDot());
                }
                catch (final Throwable jjte003)
                {
                    if (jjtc003)
                    {
                        this.jjtree.clearNodeScope(jjtn003);
                        jjtc003 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte003 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte003;
                    }
                    if (jjte003 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte003;
                    }
                    {
                        if (true) throw (Error) jjte003;
                    }
                }
                finally
                {
                    if (jjtc003) this.jjtree.closeNodeScope(jjtn003, 2);
                }
                break;
            case CROSS:
                final ASTFunNode jjtn004 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc004 = true;
                this.jjtree.openNodeScope(jjtn004);
                try
                {
                    this.jj_consume_token(ParserConstants.CROSS);
                    this.UnaryExpression();
                    this.jjtree.closeNodeScope(jjtn004, 2);
                    jjtc004 = false;
                    jjtn004.setOperator(this.opSet.getCross());
                }
                catch (final Throwable jjte004)
                {
                    if (jjtc004)
                    {
                        this.jjtree.clearNodeScope(jjtn004);
                        jjtc004 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte004 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte004;
                    }
                    if (jjte004 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte004;
                    }
                    {
                        if (true) throw (Error) jjte004;
                    }
                }
                finally
                {
                    if (jjtc004) this.jjtree.closeNodeScope(jjtn004, 2);
                }
                break;
            case DIV:
                final ASTFunNode jjtn005 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc005 = true;
                this.jjtree.openNodeScope(jjtn005);
                try
                {
                    this.jj_consume_token(ParserConstants.DIV);
                    this.UnaryExpression();
                    this.jjtree.closeNodeScope(jjtn005, 2);
                    jjtc005 = false;
                    jjtn005.setOperator(this.opSet.getDivide());
                }
                catch (final Throwable jjte005)
                {
                    if (jjtc005)
                    {
                        this.jjtree.clearNodeScope(jjtn005);
                        jjtc005 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte005 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte005;
                    }
                    if (jjte005 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte005;
                    }
                    {
                        if (true) throw (Error) jjte005;
                    }
                }
                finally
                {
                    if (jjtc005) this.jjtree.closeNodeScope(jjtn005, 2);
                }
                break;
            case MOD:
                final ASTFunNode jjtn006 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc006 = true;
                this.jjtree.openNodeScope(jjtn006);
                try
                {
                    this.jj_consume_token(ParserConstants.MOD);
                    this.UnaryExpression();
                    this.jjtree.closeNodeScope(jjtn006, 2);
                    jjtc006 = false;
                    jjtn006.setOperator(this.opSet.getMod());
                }
                catch (final Throwable jjte006)
                {
                    if (jjtc006)
                    {
                        this.jjtree.clearNodeScope(jjtn006);
                        jjtc006 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte006 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte006;
                    }
                    if (jjte006 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte006;
                    }
                    {
                        if (true) throw (Error) jjte006;
                    }
                }
                finally
                {
                    if (jjtc006) this.jjtree.closeNodeScope(jjtn006, 2);
                }
                break;
            default:
                this.jj_la1[11] = this.jj_gen;
                this.jj_consume_token(-1);
                throw new ParseException();
            }
        }
    }

    final public void OrExpression() throws ParseException
    {
        this.AndExpression();
        label_1:
        while (true)
        {
            switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case OR:
                ;
                break;
            default:
                this.jj_la1[3] = this.jj_gen;
                break label_1;
            }
            final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
            boolean jjtc001 = true;
            this.jjtree.openNodeScope(jjtn001);
            try
            {
                this.jj_consume_token(ParserConstants.OR);
                this.AndExpression();
                this.jjtree.closeNodeScope(jjtn001, 2);
                jjtc001 = false;
                jjtn001.setOperator(this.opSet.getOr());
            }
            catch (final Throwable jjte001)
            {
                if (jjtc001)
                {
                    this.jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                }
                else this.jjtree.popNode();
                if (jjte001 instanceof RuntimeException)
                {
                    if (true) throw (RuntimeException) jjte001;
                }
                if (jjte001 instanceof ParseException)
                {
                    if (true) throw (ParseException) jjte001;
                }
                {
                    if (true) throw (Error) jjte001;
                }
            }
            finally
            {
                if (jjtc001) this.jjtree.closeNodeScope(jjtn001, 2);
            }
        }
    }

    public Node parseStream(java.io.Reader stream, JEP jep_in) throws ParseException
    {
        this.restart(stream, jep_in);
        // Parse the expression, and return the
        this.enable_tracing();
        final Node node = this.Start();
        if (node == null) throw new ParseException("No expression entered");
        return node.jjtGetChild(0);
    }

    final public void PowerExpression() throws ParseException
    {
        this.UnaryExpressionNotPlusMinus();
        switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
        {
        case POWER:
            final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
            boolean jjtc001 = true;
            this.jjtree.openNodeScope(jjtn001);
            try
            {
                this.jj_consume_token(ParserConstants.POWER);
                this.UnaryExpression();
                this.jjtree.closeNodeScope(jjtn001, 2);
                jjtc001 = false;
                jjtn001.setOperator(this.opSet.getPower());
            }
            catch (final Throwable jjte001)
            {
                if (jjtc001)
                {
                    this.jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                }
                else this.jjtree.popNode();
                if (jjte001 instanceof RuntimeException)
                {
                    if (true) throw (RuntimeException) jjte001;
                }
                if (jjte001 instanceof ParseException)
                {
                    if (true) throw (ParseException) jjte001;
                }
                {
                    if (true) throw (Error) jjte001;
                }
            }
            finally
            {
                if (jjtc001) this.jjtree.closeNodeScope(jjtn001, 2);
            }
            break;
        default:
            this.jj_la1[13] = this.jj_gen;
            ;
        }
    }

    /*
     * Vector Array() :
     * {
     * Object value;
     * Vector result = new Vector();
     * }
     * {
     * <LSQ>
     * value = RealConstant()
     * {
     * result.addElement(value);
     * }
     * (
     * <COMMA>
     * value = RealConstant()
     * {
     * result.addElement(value);
     * }
     * )*
     * <RSQ>
     * {
     * return result;
     * }
     * }
     */
    final public Object RealConstant() throws ParseException
    {
        Token t;
        Object value;
        switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
        {
        case INTEGER_LITERAL:
            t = this.jj_consume_token(ParserConstants.INTEGER_LITERAL);
            break;
        case FLOATING_POINT_LITERAL:
            t = this.jj_consume_token(ParserConstants.FLOATING_POINT_LITERAL);
            break;
        default:
            this.jj_la1[21] = this.jj_gen;
            this.jj_consume_token(-1);
            throw new ParseException();
        }
        try
        {
            value = this.jep.getNumberFactory().createNumber(t.image);
        }
        catch (final Exception e)
        {
            value = null;
            this.addToErrorList("Can't parse \"" + t.image + "\"");
        }

        {
            if (true) return value;
        }
        throw new Error("Missing return statement in function");
    }

    public void ReInit(java.io.InputStream stream)
    {
        this.jj_input_stream.ReInit(stream, 1, 1);
        this.token_source.ReInit(this.jj_input_stream);
        this.token = new Token();
        this.jj_ntk = -1;
        this.jjtree.reset();
        this.jj_gen = 0;
        for (int i = 0; i < 22; i++)
            this.jj_la1[i] = -1;
        for (int i = 0; i < this.jj_2_rtns.length; i++)
            this.jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(java.io.Reader stream)
    {
        this.jj_input_stream.ReInit(stream, 1, 1);
        this.token_source.ReInit(this.jj_input_stream);
        this.token = new Token();
        this.jj_ntk = -1;
        this.jjtree.reset();
        this.jj_gen = 0;
        for (int i = 0; i < 22; i++)
            this.jj_la1[i] = -1;
        for (int i = 0; i < this.jj_2_rtns.length; i++)
            this.jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(ParserTokenManager tm)
    {
        this.token_source = tm;
        this.token = new Token();
        this.jj_ntk = -1;
        this.jjtree.reset();
        this.jj_gen = 0;
        for (int i = 0; i < 22; i++)
            this.jj_la1[i] = -1;
        for (int i = 0; i < this.jj_2_rtns.length; i++)
            this.jj_2_rtns[i] = new JJCalls();
    }

    final public void RelationalExpression() throws ParseException
    {
        this.AdditiveExpression();
        label_4:
        while (true)
        {
            switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case GT:
            case LT:
            case LE:
            case GE:
                ;
                break;
            default:
                this.jj_la1[7] = this.jj_gen;
                break label_4;
            }
            switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case LT:
                final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc001 = true;
                this.jjtree.openNodeScope(jjtn001);
                try
                {
                    this.jj_consume_token(ParserConstants.LT);
                    this.AdditiveExpression();
                    this.jjtree.closeNodeScope(jjtn001, 2);
                    jjtc001 = false;
                    jjtn001.setOperator(this.opSet.getLT());
                }
                catch (final Throwable jjte001)
                {
                    if (jjtc001)
                    {
                        this.jjtree.clearNodeScope(jjtn001);
                        jjtc001 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte001 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte001;
                    }
                    if (jjte001 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte001;
                    }
                    {
                        if (true) throw (Error) jjte001;
                    }
                }
                finally
                {
                    if (jjtc001) this.jjtree.closeNodeScope(jjtn001, 2);
                }
                break;
            case GT:
                final ASTFunNode jjtn002 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc002 = true;
                this.jjtree.openNodeScope(jjtn002);
                try
                {
                    this.jj_consume_token(ParserConstants.GT);
                    this.AdditiveExpression();
                    this.jjtree.closeNodeScope(jjtn002, 2);
                    jjtc002 = false;
                    jjtn002.setOperator(this.opSet.getGT());
                }
                catch (final Throwable jjte002)
                {
                    if (jjtc002)
                    {
                        this.jjtree.clearNodeScope(jjtn002);
                        jjtc002 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte002 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte002;
                    }
                    if (jjte002 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte002;
                    }
                    {
                        if (true) throw (Error) jjte002;
                    }
                }
                finally
                {
                    if (jjtc002) this.jjtree.closeNodeScope(jjtn002, 2);
                }
                break;
            case LE:
                final ASTFunNode jjtn003 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc003 = true;
                this.jjtree.openNodeScope(jjtn003);
                try
                {
                    this.jj_consume_token(ParserConstants.LE);
                    this.AdditiveExpression();
                    this.jjtree.closeNodeScope(jjtn003, 2);
                    jjtc003 = false;
                    jjtn003.setOperator(this.opSet.getLE());
                }
                catch (final Throwable jjte003)
                {
                    if (jjtc003)
                    {
                        this.jjtree.clearNodeScope(jjtn003);
                        jjtc003 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte003 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte003;
                    }
                    if (jjte003 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte003;
                    }
                    {
                        if (true) throw (Error) jjte003;
                    }
                }
                finally
                {
                    if (jjtc003) this.jjtree.closeNodeScope(jjtn003, 2);
                }
                break;
            case GE:
                final ASTFunNode jjtn004 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
                boolean jjtc004 = true;
                this.jjtree.openNodeScope(jjtn004);
                try
                {
                    this.jj_consume_token(ParserConstants.GE);
                    this.AdditiveExpression();
                    this.jjtree.closeNodeScope(jjtn004, 2);
                    jjtc004 = false;
                    jjtn004.setOperator(this.opSet.getGE());
                }
                catch (final Throwable jjte004)
                {
                    if (jjtc004)
                    {
                        this.jjtree.clearNodeScope(jjtn004);
                        jjtc004 = false;
                    }
                    else this.jjtree.popNode();
                    if (jjte004 instanceof RuntimeException)
                    {
                        if (true) throw (RuntimeException) jjte004;
                    }
                    if (jjte004 instanceof ParseException)
                    {
                        if (true) throw (ParseException) jjte004;
                    }
                    {
                        if (true) throw (Error) jjte004;
                    }
                }
                finally
                {
                    if (jjtc004) this.jjtree.closeNodeScope(jjtn004, 2);
                }
                break;
            default:
                this.jj_la1[8] = this.jj_gen;
                this.jj_consume_token(-1);
                throw new ParseException();
            }
        }
    }

    /**
     * Translate all escape sequences to characters. Inspired by Rob Millar's
     * unescape() method in rcm.util.Str fron the Web Sphinx project.
     *
     * @param inputStr
     *            String containing escape characters.
     * @return String with all escape sequences replaced.
     */
    private String replaceEscape(String inputStr)
    {
        final int len = inputStr.length();
        int p = 0;
        int i;
        final String metachars = "tnrbf\\\"'";
        final String chars = "\t\n\r\b\f\\\"'";

        final StringBuffer output = new StringBuffer();

        while ((i = inputStr.indexOf('\\', p)) != -1)
        {
            output.append(inputStr.substring(p, i));

            if (i + 1 == len) break;

            // find metacharacter
            final char metac = inputStr.charAt(i + 1);

            // find the index of the metac
            final int k = metachars.indexOf(metac);
            if (k == -1)
            {
                // didn't find the metachar, leave sequence as found.
                // This code should be unreachable if the parser
                // is functioning properly because strings containing
                // unknown escape characters should not be accepted.
                output.append('\\');
                output.append(metac);
            }
            else // its corresponding true char
                output.append(chars.charAt(k));

            // skip over both escape character & metacharacter
            p = i + 2;
        }

        // add the end of the input string to the output
        if (p < len) output.append(inputStr.substring(p));

        return output.toString();
    }

    /**
     * Restart the parse with the given stream.
     * 
     * @since 2.3.0 beta 1
     */
    public void restart(java.io.Reader stream, JEP jep_in)
    {
        this.ReInit(stream);
        this.token_source.SwitchTo(this.initialTokenManagerState);
        this.jep = jep_in;
        this.symTab = this.jep.getSymbolTable();
        this.opSet = this.jep.getOperatorSet();
    }

    /**
     * Sets the initial state that the token manager is in.
     * Can be used to change how x.x is interpreted, either as a single
     * identifier (DEFAULT) or as x <DOT> x (NO_DOT_IN_IDENTIFIERS)
     * 
     * @param state
     *            the state to be in. Currently the only legal values are
     *            DEFAULT and NO_DOT_IN_IDENTIFIER
     */
    public void setInitialTokenManagerState(int state)
    {
        this.initialTokenManagerState = state;
    }

    /***************************************************************
     * GRAMMAR START
     ***************************************************************/
    final public ASTStart Start() throws ParseException
    {
        /* @bgen(jjtree) Start */
        final ASTStart jjtn000 = new ASTStart(ParserTreeConstants.JJTSTART);
        boolean jjtc000 = true;
        this.jjtree.openNodeScope(jjtn000);
        try
        {
            if (this.jj_2_1(1))
            {
                this.Expression();
                switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
                {
                case 0:
                    this.jj_consume_token(0);
                    break;
                case SEMI:
                    this.jj_consume_token(ParserConstants.SEMI);
                    break;
                default:
                    this.jj_la1[0] = this.jj_gen;
                    this.jj_consume_token(-1);
                    throw new ParseException();
                }
                this.jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                {
                    if (true) return jjtn000;
                }
            }
            else switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case 0:
            case SEMI:
                switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
                {
                case 0:
                    this.jj_consume_token(0);
                    break;
                case SEMI:
                    this.jj_consume_token(ParserConstants.SEMI);
                    break;
                default:
                    this.jj_la1[1] = this.jj_gen;
                    this.jj_consume_token(-1);
                    throw new ParseException();
                }
                this.jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
            // njf - The next line is commented out in 2.3.0 since
            // two "No expression entered" errors are reported
            // in EvaluatorVisitor and Console (one from here
            // the other from ParseStream() )
            // Decided to just return null, and handle the error
            // in ParseStream.
            // addToErrorList("No expression entered");
            {
                if (true) return null;
            }
                break;
            default:
                this.jj_la1[2] = this.jj_gen;
                this.jj_consume_token(-1);
                throw new ParseException();
            }
        }
        catch (final Throwable jjte000)
        {
            if (jjtc000)
            {
                this.jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            }
            else this.jjtree.popNode();
            if (jjte000 instanceof RuntimeException)
            {
                if (true) throw (RuntimeException) jjte000;
            }
            if (jjte000 instanceof ParseException)
            {
                if (true) throw (ParseException) jjte000;
            }
            {
                if (true) throw (Error) jjte000;
            }
        }
        finally
        {
            if (jjtc000) this.jjtree.closeNodeScope(jjtn000, true);
        }
        throw new Error("Missing return statement in function");
    }

    final public void UnaryExpression() throws ParseException
    {
        switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
        {
        case PLUS:
            this.jj_consume_token(ParserConstants.PLUS);
            this.UnaryExpression();
            break;
        case MINUS:
            final ASTFunNode jjtn001 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
            boolean jjtc001 = true;
            this.jjtree.openNodeScope(jjtn001);
            try
            {
                this.jj_consume_token(ParserConstants.MINUS);
                this.UnaryExpression();
                this.jjtree.closeNodeScope(jjtn001, 1);
                jjtc001 = false;
                jjtn001.setOperator(this.opSet.getUMinus());
            }
            catch (final Throwable jjte001)
            {
                if (jjtc001)
                {
                    this.jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                }
                else this.jjtree.popNode();
                if (jjte001 instanceof RuntimeException)
                {
                    if (true) throw (RuntimeException) jjte001;
                }
                if (jjte001 instanceof ParseException)
                {
                    if (true) throw (ParseException) jjte001;
                }
                {
                    if (true) throw (Error) jjte001;
                }
            }
            finally
            {
                if (jjtc001) this.jjtree.closeNodeScope(jjtn001, 1);
            }
            break;
        case NOT:
            final ASTFunNode jjtn002 = new ASTFunNode(ParserTreeConstants.JJTFUNNODE);
            boolean jjtc002 = true;
            this.jjtree.openNodeScope(jjtn002);
            try
            {
                this.jj_consume_token(ParserConstants.NOT);
                this.UnaryExpression();
                this.jjtree.closeNodeScope(jjtn002, 1);
                jjtc002 = false;
                jjtn002.setOperator(this.opSet.getNot());
            }
            catch (final Throwable jjte002)
            {
                if (jjtc002)
                {
                    this.jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                }
                else this.jjtree.popNode();
                if (jjte002 instanceof RuntimeException)
                {
                    if (true) throw (RuntimeException) jjte002;
                }
                if (jjte002 instanceof ParseException)
                {
                    if (true) throw (ParseException) jjte002;
                }
                {
                    if (true) throw (Error) jjte002;
                }
            }
            finally
            {
                if (jjtc002) this.jjtree.closeNodeScope(jjtn002, 1);
            }
            break;
        default:
            this.jj_la1[12] = this.jj_gen;
            if (this.jj_2_6(1)) this.PowerExpression();
            else
            {
                this.jj_consume_token(-1);
                throw new ParseException();
            }
        }
    }

    final public void UnaryExpressionNotPlusMinus() throws ParseException
    {
        switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
        {
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
            this.AnyConstant();
            break;
        default:
            this.jj_la1[15] = this.jj_gen;
            if (this.jj_2_7(1))
            {
                if ((this.getToken(1).kind == ParserConstants.INDENTIFIER1 || this.getToken(
                        1).kind == ParserConstants.INDENTIFIER2) && this.jep.funTab.containsKey(this.getToken(1).image))
                    this.Function();
                else switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
                {
                case INDENTIFIER1:
                case INDENTIFIER2:
                    this.Variable();
                    break;
                default:
                    this.jj_la1[14] = this.jj_gen;
                    this.jj_consume_token(-1);
                    throw new ParseException();
                }
            }
            else switch (this.jj_ntk == -1 ? this.jj_ntk() : this.jj_ntk)
            {
            case LRND:
                this.jj_consume_token(ParserConstants.LRND);
                this.Expression();
                this.jj_consume_token(ParserConstants.RRND);
                break;
            case LSQ:
                this.ListExpression();
                break;
            default:
                this.jj_la1[16] = this.jj_gen;
                this.jj_consume_token(-1);
                throw new ParseException();
            }
        }
    }

    final public void Variable() throws ParseException
    {
        String identString = "";
        final ASTVarNode jjtn001 = new ASTVarNode(ParserTreeConstants.JJTVARNODE);
        boolean jjtc001 = true;
        this.jjtree.openNodeScope(jjtn001);
        try
        {
            identString = this.Identifier();
            this.jjtree.closeNodeScope(jjtn001, true);
            jjtc001 = false;
            if (this.symTab.containsKey(identString)) jjtn001.setVar(this.symTab.getVar(identString));
            else if (this.jep.allowUndeclared) jjtn001.setVar(this.symTab.makeVarIfNeeded(identString));
            else this.addToErrorList("Unrecognized symbol \"" + identString + "\"");
        }
        catch (final Throwable jjte001)
        {
            if (jjtc001)
            {
                this.jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
            }
            else this.jjtree.popNode();
            if (jjte001 instanceof RuntimeException)
            {
                if (true) throw (RuntimeException) jjte001;
            }
            if (jjte001 instanceof ParseException)
            {
                if (true) throw (ParseException) jjte001;
            }
            {
                if (true) throw (Error) jjte001;
            }
        }
        finally
        {
            if (jjtc001) this.jjtree.closeNodeScope(jjtn001, true);
        }
    }

}
